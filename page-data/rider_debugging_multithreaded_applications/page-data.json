{"componentChunkName":"component---src-templates-blog-post-js","path":"/rider_debugging_multithreaded_applications/","result":{"data":{"markdownRemark":{"html":"<p>원문: <a href=\"https://www.jetbrains.com/help/rider/Debugging_Multithreaded_Applications.html\">Run, debug, test, deploy | Debugging | Debug multithreaded applications</a></p>\n<p>멀티스레드 어플리케이션은 여러 스레드를 동시에 추적해야 하기 때문에 디버깅하기 힘들다. 심지어, 멀티스레드 어플리케이션은 불균등한 부하 분산, 락(lock) 경쟁, 직렬화된 실행 등의 새로운 형태의 버그와 성능 문제를 일으킨다.</p>\n<p>멀티스레드 앱에서 순서대로 밟아나가는 디버깅 세션의 순차적 플로우의 환상은 실수를 유발할 수 있다. 동시성(concurrency) 버그를 일으킬 수 있는 문제를 조사 중일 때는 순서대로 밟아나가는 디버깅보다는 브레이크포인트를 거는 것이 하나의 스레드에 집중하기에는 더 좋을 수 있다. 스레드에 스레드 ID 등의 유일무이한 프로퍼티를 추가함으로써 브레이크포인트를 실행시키면 어떤 스레드든 해당 객체의 표시된 프로퍼티를 변경시키는 순간 데이터 프레이크포인트가 실행을 멈출 것이다.</p>\n<p>JetBrains의 Rider는 멀티스레드 어플리케이션의 디버깅을 단순화시키는 다음 기능들을 제공한다:</p>\n<ul>\n<li>좌측의 <strong>Threads</strong> 패널은 어플리케이션의 모든 스레드들을 표시한다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 509px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f363b6a5687d944d9e65aa9f8e6a3db4/71554/debug_frames_select_thread.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 23.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABBElEQVQY042My27CMBBF8/8/0kUXqJ9QqQJVPFQKdRwgD5s8iGlIobEDbE6FK7ru4uieOzOaIE5iIhkRbzaoTHkXH8KnlBFaa0IhvCulSdOUMPzdraI1Kte8RTNCsWIpJEGxM8RZwUKsKesD++ZIWTeYfUOhS5QqkDIhSTRVtaMoKrTK0Tr3npeGWJeUpkVuFMFLdORxZHh43jJ4NTyN9wwmLW9xQyRCxpM5w9GE4WjMYhkym70znc49N5dyTZIoskxT5DnBof1iV3+SpFsO7ZHO9Xx3js46nHNYa312nf3rd+6zvu+x1lEbQ3A6HbleLlyvF87nnr53HmetP/wvt8dVVfED3HRwGLICaD8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"debug_frames_select_thread\"\n        title=\"debug_frames_select_thread\"\n        src=\"/static/f363b6a5687d944d9e65aa9f8e6a3db4/71554/debug_frames_select_thread.png\"\n        srcset=\"/static/f363b6a5687d944d9e65aa9f8e6a3db4/772e8/debug_frames_select_thread.png 200w,\n/static/f363b6a5687d944d9e65aa9f8e6a3db4/e17e5/debug_frames_select_thread.png 400w,\n/static/f363b6a5687d944d9e65aa9f8e6a3db4/71554/debug_frames_select_thread.png 509w\"\n        sizes=\"(max-width: 509px) 100vw, 509px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>\n<p>우측의 <strong>Frames</strong> 화면은 선택된 스레드의 모든 스택 프레임을 표시한다.</p>\n</li>\n<li>\n<p><strong>Parallel Stacks</strong> 패널은 스레드 분석을 단순화시켜 스레드와 해당 스레드의 스택 프레임을 다이어그램의 형태로 표시한다.</p>\n</li>\n</ul>","frontmatter":{"title":"[Rider] Rider에서 멀티스레드 어플리케이션 디버깅하기"},"excerpt":"원문: Run, debug, test, deploy | Debugging | Debug multithreaded applications…"}},"pageContext":{"slug":"/rider_debugging_multithreaded_applications/"}},"staticQueryHashes":["3159585216","63159454"]}